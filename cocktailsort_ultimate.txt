/* cocktail sort */
#include <stdio.h>
#include <mpi.h>
#include <time.h>
#include <crtdbg.h>
#include <corecrt_malloc.h>
#include <cstdlib>

#define N 30000
#define _CRT_SECURE_NO_WARNINGS
#pragma warning(disable:4996)

void showElapsed(int id, char* m);
void showVector(int* v, int n, int id);
int* merge(int* v1, int n1, int* v2, int n2);
void swap(int* v, int i, int j);
void sort(int* v, int n);

double startT, stopT;

double startTime;
int temp;
void showElapsed(int id, char* m)
{
	printf("%d: %s %f secs\n", id, m, (clock() - startTime) / CLOCKS_PER_SEC);
}

void showVector(int* v, int n, int id)
{
	int i;
	printf("%d: ", id);
	for (i = 0; i < n; i++)
		printf("%d ", v[i]);
	putchar('\n');
}

int* merge(int* v1, int n1, int* v2, int n2)
{
	int i, j, k;
	int* result;

	result = (int*)malloc((n1 + n2) * sizeof(int));

	/*
		i : pointer of v1
		j : pointer of v2
		k : pointer of k
	*/
	i = 0; j = 0; k = 0;
	while (i < n1 && j < n2)
		if (v1[i] < v2[j])
		{
			result[k] = v1[i];
			i++; k++;
		}
		else
		{
			result[k] = v2[j];
			j++; k++;
		}
	if (i == n1)
		while (j < n2)
		{
			result[k] = v2[j];
			j++; k++;
		}
	else
		while (i < n1)
		{
			result[k] = v1[i];
			i++; k++;
		}
	return result;
}

void swap(int* v, int i, int j)
{
	int t;
	t = v[i];
	v[i] = v[j];
	v[j] = t;
}

void sort(int* a, int n)
{
	int is_swapped = 1;
	int begin = 0, i;
	int end = n - 1;

	while (is_swapped) {
		is_swapped = 0;
		for (i = begin; i < end; ++i) {
			if (a[i] > a[i + 1]) {
				temp = a[i];
				a[i] = a[i + 1];
				a[i + 1] = temp;
				is_swapped = 1;
			}
		}
		if (!is_swapped)
			break;
		is_swapped = 0;
		for (i = end - 1; i >= begin; --i) {
			if (a[i] > a[i + 1])
			{
				temp = a[i];
				a[i] = a[i + 1];
				a[i + 1] = temp;
				is_swapped = 1;
			}
		}
		++begin;
	}
}

int main(int argc, char** argv)
{
	int* data = NULL;
	int* chunk;
	int* other;
	int m, n = N;
	int id, p;
	int s;
	int i;
	int step;
	MPI_Status status;

	MPI_Init(&argc, &argv);
	MPI_Comm_rank(MPI_COMM_WORLD, &id);
	MPI_Comm_size(MPI_COMM_WORLD, &p);

	if (id == 0)
	{
		int r;
		srand(clock());
		s = n / p; //chunks 

		r = n % p;
		//intializing size of array
		data = (int*)malloc((n + p - r) * sizeof(int));
		
		// taking data input for n elemnts using random
		for (i = 0; i < n; i++)
			data[i] = rand();
		if (r != 0)
		{
			for (i = n; i < n + p - r; i++)
				data[i] = 0;
			s = s + 1;
		}


		// initialize clock
		startT = clock();

		// brocasting number size of each chunk to all processes
		MPI_Bcast(&s, 1, MPI_INT, 0, MPI_COMM_WORLD);

		// initializing the chunk int*
		chunk = (int*)malloc(s * sizeof(int));
		MPI_Scatter(data, s, MPI_INT, chunk, s, MPI_INT, 0, MPI_COMM_WORLD);

		sort(chunk, s);
	}
	else
	{
		MPI_Bcast(&s, 1, MPI_INT, 0, MPI_COMM_WORLD);
		chunk = (int*)malloc(s * sizeof(int));
		MPI_Scatter(data, s, MPI_INT, chunk, s, MPI_INT, 0, MPI_COMM_WORLD);

		sort(chunk, s);
	}

	step = 1;
	while (step < p)
	{
		if (id % (2 * step) == 0)
		{
			if (id + step < p)
			{
				MPI_Recv(&m, 1, MPI_INT, id + step, 0, MPI_COMM_WORLD, &status);
				other = (int*)malloc(m * sizeof(int));
				MPI_Recv(other, m, MPI_INT, id + step, 0, MPI_COMM_WORLD, &status);
				chunk = merge(chunk, s, other, m);
				s = s + m;
			}
		}
		else
		{
			int near = id - step;
			MPI_Send(&s, 1, MPI_INT, near, 0, MPI_COMM_WORLD);
			MPI_Send(chunk, s, MPI_INT, near, 0, MPI_COMM_WORLD);
			break;
		}
		step = step * 2;
	}

	stopT = clock();
	if (id == 0)
	{
		FILE* fout;

		
		printf("%d; %d processors; %f secs\n", N, p, (stopT - startT) / CLOCKS_PER_SEC);

		fout = fopen("result", "w");
		for (i = 0; i < s; i++)
			if (chunk[i] != 0)
				fprintf(fout, "%d\n", chunk[i]);
		fclose(fout);
	}
	MPI_Finalize();

	return 0;
}